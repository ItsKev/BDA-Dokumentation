\chapter{Multi User Interaktion}
\label{ch:Multi_User_Interaktion}

\section{Realisierung}
Mit dem Projekt und den Erkenntnissen des Single-User Prototypen begann die Erstellung eines Multi-User tauglichen Prototypen.

\subsection{Multi User}
\label{ch:multi_user}
Um die Applikation Multi-User tauglich zu machen, wurde die Photon-Engine verwendet (\cite{noauthor_photon_2019}). Diese Engine stellt ein Unity-Asset zur Verfügung mit verschiedenen Beispielen wie die Engine einzusetzen ist. \\

\noindent Auf der Webseite von Photon kann nach einem erfolgreichen Login eine neue Applikation erstellt werden. Für den Multi-User Prototyp wurde eine Realtime-Applikation erstellt mit bis zu 20 gleichzeitigen Benutzern. Soll eine Applikation mit mehr als 20 gleichzeitigen Nutzern erstellt werden, wird dies kostenpflichtig. Nach dem erstellen kann die erhaltene App ID, zu sehen in Abbildung \ref{fig:photon_dashboard}, in Unity verwendet werden.

\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio,width=0.4\linewidth]{img/Photon_Dashboard.PNG}
	\caption{Photon Dashboard}
	\label{fig:photon_dashboard}
\end{figure} 

Mit der App ID kann Unity sich nun auf die Applikation verbinden. Die erste Instanz, welche sich verbindet wird automatisch als Master deklariert. Um nun mit anderen Instanzen kommunizieren zu können, müssen diese sich mit einen virtuellen Raum verbinden. Sobald sich beide im gleichen Raum befinden, kann die Kommunikation beginnen.\\
Jeglichen Objekten, welche nun untereinander synchronisiert werden sollen, muss die Komponente Photon View hinzugefügt werden. Diese besitzt die folgenden Parameter:
\begin{itemize} [itemsep=1pt]
	\item Owner: Der aktuelle Besitzer der Objekts
	\item View ID: Eindeutige Identität des Objektes
	\item Observed Components: Welche Komponenten des Objektes mit den anderen Instanzen synchronisiert werden soll.
\end{itemize}

Für die Synchronisation vieler standardmässigen Unity-Komponenten stellt die Photon-Engine schon Komponenten zur Verfügung. Eine dieser Komponenten, die Photon Transform View, wurde im Prototyp verwendet, um die Position und die Rotation des Objektes zu synchronisieren. Somit werden diese beiden Eigenschaften mit allen Instanzen synchronisiert, welche nicht Besitzer des Objektes sind. Es ist aber nicht möglich als Nicht-Besitzer ein Objekt zu bewegen. \\
Die Master-Instanz wird bei der Initialisierung Besitzer von allen Objekten, welche eine Photon View besitzen. Um als Nicht-Master-Instanz nun ein Objekt bewegen zu können, stellt die Photon-Engine die Funktion \textit{RequestOwnership()} zur Verfügung. Diese Funktion macht die Instanz zum neuen Besitzer der Photon View, welche die Funktion aufgerufen hat. Somit kann nun die Nicht-Master-Instanz das Bauteil bewegen und alle anderen Instanzen sehen diese Bewegung. \\

\noindent Da die Bauteile im Prototyp einen Rigidbody angehängt haben, muss auch dieser synchronisiert werden. Die Photon-Engine stellt aber für die Synchronisation eines Rigidbody keine Komponenten zur Verfügung. Sie stellt aber die Methode \textit{OnPhotonSerializeView(PhotonStream stream, PhotonMessageInfo info)} zur Verfügung, mit welcher eigene Attribute zwischen den Instanzen synchronisiert werden können. Die Methode wird standardmässig 10 mal in der Sekunde aufgerufen, kann aber in den Einstellungen angepasst werden. Nachfolgend ein Ausschnitt wie der Aufbau dieser Methode aussehen sollte.

\begin{algorithm}
	\KwIn{PhotonStream, PhotonMessageInfo}
	\eIf{Falls die aktuelle Instanz auf den Stream schreiben kann} {
		Schreibe alle Informationen des Rigidbody auf den Stream\;
		Schreibe weitere Attribute auf den Stream\;
	}{
		Lese die Informationen aus dem Stream und speichere diese in den Rigidbody\;
		Lese die weiteren Attribute aus dem Stream\;	
	}
\end{algorithm}

Eine Instanz kann nur dann auf den Stream schreiben, wenn sie in besitzt der Photon View ist. Die Komponente Photon Transform View funktioniert sehr ähnlich wie der beschriebene Pseudocode.

\subsection{Avatar-Repräsentation in der virtuellen Umgebung}

Wie in Kapitel \ref{ch:avatar_repraesentation_realisierung} beschrieben, wurde für diesen Prototyp ein einfacher Avatar bestehend aus Kopf, Oberkörper und den beiden Händen umgesetzt. Dieser ist in Abbildung \ref{fig:avatar} zu sehen mit Controllern als Hände. Die Position und Rotation des Oberkörpers werden anhand der Position sowie der Rotation des Kopfes berechnet.

\begin{figure}[h!]
	\centering
	\includegraphics[keepaspectratio,width=0.4\linewidth]{img/Avatar.PNG}
	\caption{Avatar leicht nach links blickend}
	\label{fig:avatar}
\end{figure} 

Der Benutzer selbst sieht von seinem eigenen Avatar nur die Hände mit den Controllern. Der Oberkörper sowie der Kopf sind für ihn unsichtbar, da sie sonst in der Quere des Sichtfelds sein würden. Um den Avatar mit den anderen Instanzen zu synchronisieren wurde ebenfalls, wie in Kapitel \ref{ch:multi_user} beschrieben, auf jede Komponente des Avatars eine Photon View hinzugefügt. Somit sehen die Benutzer sich untereinander und können mithilfe von Gesten miteinander Kommunizieren.

\subsection{Kommunikation zwischen den Benutzern}

Für die Kommunikation zwischen den Benutzern wurde ebenfalls auf die Photon-Engine zurückgegriffen. Im Photon Dashboard, zu sehen in Abbildung \ref{fig:photon_dashboard}, wurde eine Voice Applikation erstellt und die erhaltene App ID konnte dann in Unity, zusätzlich zu der App ID für die Realtime-Applikation, eingeben werden. \\

\noindent Um die Voice Applikation nutzen zu können, muss einem leeren GameObject in der Szene eine \grqq Photon Voice Network\grqq{} Komponente sowie ein \grqq Recorder\grqq{} hinzugefügt werden. Diese Komponenten sind ebenfalls aus einem Plugin der Photon-Engine namens Photon Voice (\cite{noauthor_photon_2019-1}). So wird der Sound über das Mikrophon des Benutzers aufgenommen. Für die Wiedergabe wurde dem Avatar zusätzlich eine \grqq Speaker\grqq{}-Komponente, welche ebenfalls aus dem Photon Voice Plugin stammt, hinzugefügt. Somit können die Benutzer miteinander über grosse Distanzen kommunizieren. 

\subsection{Gleichzeitige Interaktion am selben Objekt}



\section{Evaluation}

\section{Schlussfolgerung}

\section{Systemarchitektur}

\section{Klassendiagramm}